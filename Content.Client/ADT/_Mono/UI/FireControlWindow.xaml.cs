using System.Linq;
using Content.Client.UserInterface.Controls;
using Content.Shared.ADT._Mono.FireControl;
using Content.Shared.ADT._Mono.ShipGuns;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface.Controls;

namespace Content.Client.ADT._Mono.FireControl.UI;

[GenerateTypedNameReferences]
public sealed partial class FireControlWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entityManager = default!;

    public FireControlNavControl Radar => NavRadar;
    public Action? OnServerRefresh;
    public Action? OnWeaponSelectionChanged;

    public readonly Dictionary<NetEntity, Button> WeaponsList = new();

    // Dictionary to store weapon name to entity mapping for easier filtering
    private readonly Dictionary<string, NetEntity> _weaponNameToEntity = new();

    // Dictionary to store weapon entity to type mapping
    private readonly Dictionary<NetEntity, ShipGunType> _weaponTypes = new();

    private FireControlConsoleBoundInterfaceState? _currentState;

    public FireControlWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        RefreshButton.OnPressed += _ => OnServerRefresh?.Invoke();
        SelectAllButton.OnPressed += SelectAllWeapons;
        UnselectAllButton.OnPressed += UnselectAllWeapons;
        SelectBallisticButton.OnPressed += SelectBallisticWeapons;
        SelectEnergyButton.OnPressed += SelectEnergyWeapons;
        SelectMissileButton.OnPressed += SelectMissileWeapons;
    }

    private void SelectAllWeapons(BaseButton.ButtonEventArgs args)
    {
        foreach (var button in WeaponsList.Values)
        {
            button.Pressed = true;
        }

        OnWeaponSelectionChanged?.Invoke();

        UpdateAllWeaponButtonTexts();
    }

    private void UnselectAllWeapons(BaseButton.ButtonEventArgs args)
    {
        foreach (var button in WeaponsList.Values)
        {
            button.Pressed = false;
        }

        OnWeaponSelectionChanged?.Invoke();

        UpdateAllWeaponButtonTexts();
    }

    private void SelectBallisticWeapons(BaseButton.ButtonEventArgs args)
    {
        // First unselect all weapons
        foreach (var button in WeaponsList.Values)
        {
            button.Pressed = false;
        }

        // Then select only ballistic weapons
        foreach (var kvp in WeaponsList)
        {
            var weaponEntity = kvp.Key;
            var button = kvp.Value;

            if (_weaponTypes.TryGetValue(weaponEntity, out var type) && type == ShipGunType.Ballistic)
            {
                button.Pressed = true;
            }
        }

        OnWeaponSelectionChanged?.Invoke();
        UpdateAllWeaponButtonTexts();
    }

    private void SelectEnergyWeapons(BaseButton.ButtonEventArgs args)
    {
        // First unselect all weapons
        foreach (var button in WeaponsList.Values)
        {
            button.Pressed = false;
        }

        // Then select only energy weapons
        foreach (var kvp in WeaponsList)
        {
            var weaponEntity = kvp.Key;
            var button = kvp.Value;

            if (_weaponTypes.TryGetValue(weaponEntity, out var type) && type == ShipGunType.Energy)
            {
                button.Pressed = true;
            }
        }

        OnWeaponSelectionChanged?.Invoke();
        UpdateAllWeaponButtonTexts();
    }

    private void SelectMissileWeapons(BaseButton.ButtonEventArgs args)
    {
        // First unselect all weapons
        foreach (var button in WeaponsList.Values)
        {
            button.Pressed = false;
        }

        // Then select only missile weapons
        foreach (var kvp in WeaponsList)
        {
            var weaponEntity = kvp.Key;
            var button = kvp.Value;

            if (_weaponTypes.TryGetValue(weaponEntity, out var type) && type == ShipGunType.Missile)
            {
                button.Pressed = true;
            }
        }

        OnWeaponSelectionChanged?.Invoke();
        UpdateAllWeaponButtonTexts();
    }

    /// <summary>
    /// Updates the text of a weapon button based on its selection state and manual reload status.
    /// </summary>
    private void UpdateWeaponButtonText(Button button, FireControllableEntry controllable)
    {
        if (button.Pressed && controllable.HasManualReload && controllable.AmmoCount.HasValue)
        {
            button.Text = controllable.AmmoCount.Value.ToString();

            if (controllable.AmmoCount.Value == 0)
            {
                button.ModulateSelfOverride = Color.Red;
            }
            else
            {
                button.ModulateSelfOverride = null;
            }
        }
        else
        {
            button.Text = controllable.Name;
            button.ModulateSelfOverride = null;
        }
    }

    /// <summary>
    /// Updates all weapon button texts based on current selection state.
    /// </summary>
    private void UpdateAllWeaponButtonTexts()
    {
        foreach (var (netEntity, button) in WeaponsList)
        {
            var controllable = _currentState?.FireControllables?.FirstOrDefault(c => c.NetEntity == netEntity);

            if (controllable.HasValue)
            {
                UpdateWeaponButtonText(button, controllable.Value);
            }
        }
    }

    public void UpdateStatus(FireControlConsoleBoundInterfaceState state)
    {
        _currentState = state;
        NavRadar.UpdateState(state.NavState);

        if (state.Connected)
        {
            ServerStatus.Text = Loc.GetString("gunnery-window-connected");
            ServerStatus.FontColorOverride = Color.Green;
        }
        else
        {
            RefreshButton.Disabled = false;
            ServerStatus.Text = Loc.GetString("gunnery-window-disconnected");
            ServerStatus.FontColorOverride = Color.Red;
        }

        UpdateWeaponsList(state);

        UpdateAllWeaponButtonTexts();

        // Update the category buttons state based on whether weapons of that type are available
        bool hasBallisticWeapons = false;
        bool hasEnergyWeapons = false;
        bool hasMissileWeapons = false;

        foreach (var kvp in _weaponTypes)
        {
            var type = kvp.Value;

            if (type == ShipGunType.Ballistic)
                hasBallisticWeapons = true;
            else if (type == ShipGunType.Energy)
                hasEnergyWeapons = true;
            else if (type == ShipGunType.Missile)
                hasMissileWeapons = true;

            if (hasBallisticWeapons && hasEnergyWeapons && hasMissileWeapons)
                break;
        }

        SelectBallisticButton.Disabled = !hasBallisticWeapons;
        SelectEnergyButton.Disabled = !hasEnergyWeapons;
        SelectMissileButton.Disabled = !hasMissileWeapons;
    }

    private void UpdateWeaponsList(FireControlConsoleBoundInterfaceState state)
    {
        if (state.FireControllables == null)
        {
            WeaponsList.Clear();
            ControllablesBox.DisposeAllChildren();
            _weaponNameToEntity.Clear();
            _weaponTypes.Clear();
            return;
        }

        var toRemove = new HashSet<NetEntity>(WeaponsList.Keys);
        _weaponNameToEntity.Clear();
        _weaponTypes.Clear();

        foreach (var controllable in state.FireControllables)
        {
            // Store the weapon name and entity for filtering
            _weaponNameToEntity[controllable.Name] = controllable.NetEntity;

            // Store the weapon type if available
            var entity = _entityManager.GetEntity(controllable.NetEntity);
            if (_entityManager.TryGetComponent<ShipGunTypeComponent>(entity, out var typeComp))
            {
                _weaponTypes[controllable.NetEntity] = typeComp.Type;
            }

            if (WeaponsList.TryGetValue(controllable.NetEntity, out var existingButton))
            {
                toRemove.Remove(controllable.NetEntity);
                UpdateWeaponButtonText(existingButton, controllable);
            }
            else
            {
                var button = new Button
                {
                    ToggleMode = true,
                    Text = controllable.Name,
                    StyleClasses = { "ButtonSquare OpenRight" },
                    HorizontalExpand = true,
                    Margin = new Thickness(4, 1)
                };

                button.OnToggled += _ =>
                {
                    OnWeaponSelectionChanged?.Invoke();
                    UpdateAllWeaponButtonTexts();
                };

                ControllablesBox.AddChild(button);
                WeaponsList.Add(controllable.NetEntity, button);

                UpdateWeaponButtonText(button, controllable);
            }
        }

        foreach (var entity in toRemove)
        {
            if (WeaponsList.TryGetValue(entity, out var button))
            {
                ControllablesBox.RemoveChild(button);
                WeaponsList.Remove(entity);
            }
        }

        SelectAllButton.Disabled = WeaponsList.Count == 0;
        UnselectAllButton.Disabled = WeaponsList.Count == 0;
    }
}
