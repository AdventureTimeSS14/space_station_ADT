using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface.Controls;
using Content.Client.UserInterface.Controls;
using System.Numerics;
using Content.Client.Stylesheets;


namespace Content.Client.ADT.Minesweeper;

[GenerateTypedNameReferences]
public sealed partial class MinesweeperWindow : FancyWindow
{
    private const int GridSize = 10;
    private const int MineCount = 15;

    private readonly Button[,] _buttons = new Button[GridSize, GridSize];
    private readonly bool[,] _mines = new bool[GridSize, GridSize];
    private readonly bool[,] _revealed = new bool[GridSize, GridSize];
    private readonly Random _rand = new();

    private GridContainer _mineGrid = default!;

    private bool _minesPlaced = false;

    public MinesweeperWindow()
    {
        RobustXamlLoader.Load(this);

        _mineGrid = new GridContainer
        {
            Columns = GridSize,
            HorizontalExpand = true,
            VerticalExpand = true,
        };

        MineContainer.AddChild(_mineGrid);

        GenerateGrid();
    }

    private void GenerateGrid()
    {
        for (int y = 0; y < GridSize; y++)
        {
            for (int x = 0; x < GridSize; x++)
            {
                var button = new Button
                {
                    MinSize = new Vector2(32, 32),
                    StyleClasses = { StyleBase.ButtonSquare },
                };

                int localX = x, localY = y;
                button.OnPressed += _ => OnTileClicked(localX, localY);

                _buttons[x, y] = button;
                _mineGrid.AddChild(button);
            }
        }
    }

    private void PlaceMinesExceptFirstClick(int safeX, int safeY)
    {
        int placed = 0;
        while (placed < MineCount)
        {
            int x = _rand.Next(GridSize);
            int y = _rand.Next(GridSize);

            // ÐŸÑ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼ ÐºÐ»ÐµÑ‚ÐºÐ¸ Ð²Ð¾ÐºÑ€ÑƒÐ³ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ ÐºÐ»Ð¸ÐºÐ° (3x3 Ð·Ð¾Ð½Ð°)
            if (x >= safeX - 1 && x <= safeX + 1 &&
                y >= safeY - 1 && y <= safeY + 1)
                continue;

            if (_mines[x, y])
                continue;

            _mines[x, y] = true;
            placed++;
        }
    }

    private void OnTileClicked(int x, int y)
    {
        if (!_minesPlaced)
        {
            PlaceMinesExceptFirstClick(x, y);
            _minesPlaced = true;
        }

        if (_revealed[x, y])
            return;

        _revealed[x, y] = true;

        if (_mines[x, y])
        {
            _buttons[x, y].Text = "ðŸ’£";
            _buttons[x, y].Modulate = Color.Red;
            RevealAllMines();
            return;
        }

        int count = CountAdjacentMines(x, y);
        _buttons[x, y].Text = count > 0 ? count.ToString() : "";
        _buttons[x, y].Disabled = true;

        if (count == 0)
        {
            RevealEmptyTiles(x, y);
        }
    }

    private void RevealEmptyTiles(int x, int y)
    {
        for (int dx = -1; dx <= 1; dx++)
        for (int dy = -1; dy <= 1; dy++)
        {
            int nx = x + dx;
            int ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < GridSize && ny < GridSize && !_revealed[nx, ny])
            {
                OnTileClicked(nx, ny);
            }
        }
    }

    private void RevealAllMines()
    {
        for (int y = 0; y < GridSize; y++)
        for (int x = 0; x < GridSize; x++)
        {
            if (_mines[x, y])
            {
                _buttons[x, y].Text = "ðŸ’£";
                _buttons[x, y].Modulate = Color.DarkRed;
            }
        }
    }

    private int CountAdjacentMines(int x, int y)
    {
        int count = 0;
        for (int dx = -1; dx <= 1; dx++)
        for (int dy = -1; dy <= 1; dy++)
        {
            int nx = x + dx;
            int ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < GridSize && ny < GridSize && _mines[nx, ny])
                count++;
        }
        return count;
    }
}
