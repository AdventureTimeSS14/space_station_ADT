using System.Linq;
using System.Numerics;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.ADT.Minesweeper;
using Robust.Client.Audio;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Timing;

namespace Content.Client.ADT.Minesweeper;

[GenerateTypedNameReferences]
public sealed partial class MinesweeperWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entManager = default!;
    private AudioSystem _audioSystem;

    // --- Константы / readonly ---
    private readonly Random _rand = new();
    private readonly Stopwatch _stopwatch = new();

    // --- Игровые настройки ---
    private int _gridSize = 10;
    private int _mineCount = 15;

    // --- Игровое состояние ---
    private bool _minesPlaced = false;
    private bool _flagMode = false;
    private bool _timerRunning = false;
    private bool _gameEnd = false;
    private TimeSpan _finalTime = TimeSpan.Zero;

    // --- Данные игры ---
    private Button[,] _buttons = new Button[1, 1];
    private bool[,] _mines = new bool[1, 1];
    private bool[,] _revealed = new bool[1, 1];
    private bool[,] _flags = new bool[1, 1];
    private List<MinesweeperRecord> _records = new();

    // --- UI ---
    private GridContainer _mineGrid = default!;

    // --- Сетевые компоненты ---
    private MinesweeperComponent _comp = default!;
    private BoundUserInterface _boundUserInterface = default!;

    // Список сложностей для выбора
    private readonly List<(string name, int size, int mines, Color themeColor, Color modulateColor)> _difficulties = new()
    {
        // ("Debug", 4, 1, Color.FromHex("#FF00FF"), Color.FromHex("#b563b5ff")), // Фиолетовый для дебага УБРАТЬ НА РЕЛИЗЕ
        (Loc.GetString("adt-minesweeper-difficulty-easy"), 8, 10, Color.FromHex("#32cd32"), Color.FromHex("#9fc19fff")),
        (Loc.GetString("adt-minesweeper-difficulty-medium"), 10, 15, Color.FromHex("#e28b00"), Color.FromHex("#cebf8fff")),
        (Loc.GetString("adt-minesweeper-difficulty-hard"), 15, 35, Color.FromHex("#cc0000"), Color.FromHex("#e4a9a9ff"))
    };

    public MinesweeperWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _audioSystem = _entManager.System<AudioSystem>();

        NewGameButton.OnPressed += _ => NewGame();

        NewGameButton.ModulateSelfOverride = Color.FromHex("#008000");

        InitializeDifficultyOptions();

        UpdateRecordsDisplay();

        NewGame();
    }

    protected override void Opened()
    {
        base.Opened();

        if (_comp != null)
            UpdateRecords(_comp);
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (_gameEnd)
        {
            TimerLabel.Text = $"{_finalTime.Minutes:D2}:{_finalTime.Seconds:D2}";
        }
        else if (_timerRunning)
        {
            var elapsed = _stopwatch.Elapsed;
            TimerLabel.Text = $"{elapsed.Minutes:D2}:{elapsed.Seconds:D2}";
        }
    }

    private void InitializeDifficultyOptions()
    {
        DifficultySelect.Clear();

        for (int i = 0; i < _difficulties.Count; i++)
        {
            DifficultySelect.AddItem(_difficulties[i].name, i);
        }

        DifficultySelect.OnItemSelected += args =>
        {
            int index = (int)args.Id;
            var selected = _difficulties[index];
            _gridSize = selected.size;
            _mineCount = selected.mines;

            ApplyDifficultyTheme(selected.themeColor);
            MineContentsContainer.Modulate = selected.modulateColor;

            DifficultySelect.SelectId(index);
            NewGame();
        };

        // Устанавливаем среднюю сложность и её цвета по умолчанию
        DifficultySelect.SelectId(1);
        ApplyDifficultyTheme(_difficulties[1].themeColor);
        MineContentsContainer.Modulate = _difficulties[1].modulateColor;
    }

    private void ApplyDifficultyTheme(Color color)
    {
        DifficultySelect.ModulateSelfOverride = color;
    }

    private void NewGame()
    {
        _gameEnd = false;
        _timerRunning = false;   // таймер пока стоит
        _stopwatch.Restart();    // обнуляем и запускаем заново
        TimerLabel.Text = Loc.GetString("minesweeper-game-timer");
        GameStatusLabel.Text = Loc.GetString("minesweeper-game-status-start");
        GameStatusLabel.FontColorOverride = Color.Green;


        _minesPlaced = false;
        _flagMode = false;

        _buttons = new Button[_gridSize, _gridSize];
        _mines = new bool[_gridSize, _gridSize];
        _revealed = new bool[_gridSize, _gridSize];
        _flags = new bool[_gridSize, _gridSize];

        MineContainer.RemoveAllChildren();

        _mineGrid = new GridContainer
        {
            Columns = _gridSize,
            HorizontalExpand = true,
            VerticalExpand = true,
        };

        MineContainer.AddChild(_mineGrid);

        GenerateGrid();
        UpdateMinesCounter();
    }

    private void GenerateGrid()
    {
        for (int y = 0; y < _gridSize; y++)
        {
            for (int x = 0; x < _gridSize; x++)
            {
                var button = new Button
                {
                    MinSize = new Vector2(32, 32),
                    MaxSize = new Vector2(32, 32),
                    StyleClasses = { StyleBase.ButtonSquare },
                    Text = string.Empty,
                    Disabled = false,
                    Modulate = Color.White
                };

                int localX = x, localY = y;

                // ЛКМ / ПКМ
                button.OnKeyBindDown += args =>
                {
                    if (args.Function == EngineKeyFunctions.UIClick) // ЛКМ
                    {
                        OnTileClicked(localX, localY);
                        args.Handle();
                    }
                    else if (args.Function == EngineKeyFunctions.UIRightClick) // ПКМ
                    {
                        if (_comp?.SoundTick != null)
                            _audioSystem.PlayPvs(_comp.SoundTick, _comp.Owner);
                        OnTileRightClicked(localX, localY);
                        args.Handle();
                    }
                };

                _buttons[x, y] = button;
                _mineGrid.AddChild(button);
            }
        }
    }

    private void OnTileRightClicked(int x, int y)
    {
        if (_gameEnd || _revealed[x, y])
            return;

        _flags[x, y] = !_flags[x, y];
        _buttons[x, y].Text = _flags[x, y] ? Loc.GetString("minesweeper-flag") : string.Empty;
        UpdateMinesCounter();
    }

    private void PlaceMinesExceptFirstClick(int safeX, int safeY)
    {
        int placed = 0;
        while (placed < _mineCount)
        {
            int x = _rand.Next(_gridSize);
            int y = _rand.Next(_gridSize);

            if (x >= safeX - 1 && x <= safeX + 1 &&
                y >= safeY - 1 && y <= safeY + 1)
                continue;

            if (_mines[x, y])
                continue;

            _mines[x, y] = true;
            placed++;
        }
    }

    public void OnTileClicked(int x, int y)
    {
        if (_gameEnd)
            return;

        if (!_minesPlaced)
        {
            PlaceMinesExceptFirstClick(x, y);
            _minesPlaced = true;
            _timerRunning = true;
        }

        if (_flagMode)
        {
            if (!_revealed[x, y])
            {
                _flags[x, y] = !_flags[x, y];
                _buttons[x, y].Text = _flags[x, y] ? Loc.GetString("minesweeper-flag") : string.Empty;
                UpdateMinesCounter();
            }
            return;
        }

        if (_revealed[x, y] || _flags[x, y])
            return;

        _revealed[x, y] = true;

        if (_mines[x, y])
        {
            _buttons[x, y].Text = Loc.GetString("minesweeper-bomb");
            _buttons[x, y].Modulate = Color.Red;
            RevealAllMines();
            GameStatusLabel.Text = Loc.GetString("minesweeper-game-status-lost");
            GameStatusLabel.FontColorOverride = Color.Red;

            _gameEnd = true;
            _timerRunning = false;
            _finalTime = _stopwatch.Elapsed;

            // Отправляем серверу
            if (_boundUserInterface != null)
                _boundUserInterface.SendMessage(new MinesweeperLostMessage());

            return;
        }

        int count = CountAdjacentMines(x, y);
        _buttons[x, y].Text = count > 0 ? count.ToString() : string.Empty;
        _buttons[x, y].Disabled = true;
        _buttons[x, y].Modulate = Color.White;

        if (count == 0)
        {
            RevealEmptyTiles(x, y);
        }

        CheckWinCondition();
    }

    private void RevealEmptyTiles(int x, int y)
    {
        for (int dx = -1; dx <= 1; dx++)
            for (int dy = -1; dy <= 1; dy++)
            {
                int nx = x + dx;
                int ny = y + dy;
                if (nx >= 0 && ny >= 0 && nx < _gridSize && ny < _gridSize && !_revealed[nx, ny])
                {
                    OnTileClicked(nx, ny);
                }
            }
    }

    private void RevealAllMines()
    {
        for (int y = 0; y < _gridSize; y++)
            for (int x = 0; x < _gridSize; x++)
            {
                if (_mines[x, y])
                {
                    _buttons[x, y].Text = Loc.GetString("minesweeper-bomb");
                    _buttons[x, y].Modulate = Color.DarkRed;
                }
            }
    }

    private int CountAdjacentMines(int x, int y)
    {
        int count = 0;
        for (int dx = -1; dx <= 1; dx++)
            for (int dy = -1; dy <= 1; dy++)
            {
                int nx = x + dx;
                int ny = y + dy;
                if (nx >= 0 && ny >= 0 && nx < _gridSize && ny < _gridSize && _mines[nx, ny])
                    count++;
            }
        return count;
    }

    private void UpdateMinesCounter()
    {
        int flagsPlaced = 0;
        for (int y = 0; y < _gridSize; y++)
        {
            for (int x = 0; x < _gridSize; x++)
            {
                if (_flags[x, y])
                    flagsPlaced++;
            }
        }
        MinesCountLabel.Text = $"{flagsPlaced}/{_mineCount}";
    }

    private void CheckWinCondition()
    {
        if (_gameEnd) // если уже закончено — не выполняем повторно
            return;

        for (int y = 0; y < _gridSize; y++)
        {
            for (int x = 0; x < _gridSize; x++)
            {
                if (!_mines[x, y] && !_revealed[x, y])
                    return;
            }
        }

        // Победа впервые
        _gameEnd = true;
        _timerRunning = false;
        _finalTime = _stopwatch.Elapsed;

        RevealAllMines();
        GameStatusLabel.Text = $"✓ Победа! \nВремя: {_finalTime.Minutes:D2}:{_finalTime.Seconds:D2}";

        var nameUser = _comp?.LastOpenedBy ?? Loc.GetString("minesweeper-unknown-record");

        var record = new MinesweeperRecord
        {
            Difficulty = _difficulties[DifficultySelect.SelectedId].name,
            TimeSeconds = (float)_stopwatch.Elapsed.TotalSeconds,
            EntityName = nameUser
        };

        _records.Add(record);
        UpdateRecordsDisplay();

        if (nameUser != null && _boundUserInterface != null)
        {
            _boundUserInterface.SendMessage(
                new MinesweeperWinMessage(
                    _difficulties[DifficultySelect.SelectedId].name,
                    (float)_stopwatch.Elapsed.TotalSeconds,
                    nameUser));
        }
    }

    public void LoadRecords(MinesweeperComponent component, BoundUserInterface boundUserInterface)
    {
        _comp = component;
        _boundUserInterface = boundUserInterface;
    }

    public void UpdateRecords(MinesweeperComponent comp)
    {
        _records = comp.Records;
        UpdateRecordsDisplay();
    }

    private void UpdateRecordsDisplay()
    {
        RecordListLabel.Text = string.Join("\n",
            _records
                .OrderBy(r => r.TimeSeconds)
                .Select(r => r.ToString()));
    }
}
